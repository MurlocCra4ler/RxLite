<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ðŸª¶ RxLite: Observable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ðŸª¶ RxLite
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_observable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Observable</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md7"></a> Observables are lazy Push collections of multiple values. They fill the missing spot in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">SINGLE   </th><th class="markdownTableHeadNone">MULTIPLE    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Pull</b>   </td><td class="markdownTableBodyNone">Function   </td><td class="markdownTableBodyNone">Iterator    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Push</b>   </td><td class="markdownTableBodyNone">Promise   </td><td class="markdownTableBodyNone">Observable   </td></tr>
</table>
<p><b>Example.</b> The following is an Observable that pushes the values 1, 2, 3 immediately (synchronously) when subscribed, and the value 4 after one second has passed since the subscribe call, then completes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;RxLite.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> observable([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">        subscriber.next(1);</div>
<div class="line">        subscriber.next(2);</div>
<div class="line">        subscriber.next(3);</div>
<div class="line">        std::thread([subscriber = subscriber.shared_from_this()]() {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">            subscriber.next(4);</div>
<div class="line">            subscriber.complete();</div>
<div class="line">        }).detach();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="aclassRxLite_1_1Observable_html"><div class="ttname"><a href="classRxLite_1_1Observable.html">RxLite::Observable</a></div><div class="ttdoc">Represents a sequence of values over time.</div><div class="ttdef"><b>Definition</b> observable.hpp:18</div></div>
</div><!-- fragment --><p>To invoke the Observable and see these values, we need to <em>subscribe</em> to it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;RxLite.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> observable([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">        subscriber.next(1);</div>
<div class="line">        subscriber.next(2);</div>
<div class="line">        subscriber.next(3);</div>
<div class="line">        std::thread([subscriber = subscriber.shared_from_this()]() {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">            subscriber.next(4);</div>
<div class="line">            subscriber.complete();</div>
<div class="line">        }).detach();</div>
<div class="line">    });</div>
<div class="line">       </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;just before subscribe&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <a class="code hl_class" href="classRxLite_1_1Subscription.html">RxLite::Subscription</a> subscription = observable.subscribe(<a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observer&lt;int&gt;</a>({</div>
<div class="line">        [](<span class="keywordtype">int</span> i) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;got value &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">        },</div>
<div class="line">        [](<span class="keyword">const</span> std::exception_ptr&amp; err) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;something wrong occurred!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::rethrow_exception(err);</div>
<div class="line">        },</div>
<div class="line">        []() {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;done&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }));</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;just after subscribe&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(2));</div>
<div class="line">}</div>
<div class="ttc" id="aclassRxLite_1_1Subscription_html"><div class="ttname"><a href="classRxLite_1_1Subscription.html">RxLite::Subscription</a></div><div class="ttdoc">Represents a disposable resource, such as the execution of an Observable.</div><div class="ttdef"><b>Definition</b> subscription.hpp:21</div></div>
</div><!-- fragment --><p>Which executes as such on the console:</p>
<div class="fragment"><div class="line">just before subscribe</div>
<div class="line">got value 1</div>
<div class="line">got value 2</div>
<div class="line">got value 3</div>
<div class="line">just after subscribe</div>
<div class="line">got value 4</div>
<div class="line">done</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Pull versus Push</h1>
<p><em>Pull</em> and <em>Push</em> are two different protocols that describe how a data <em>Producer</em> can communicate with a data <em>Consumer</em>.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
What is Pull?</h2>
<p>In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</p>
<p>Every C++ Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by "pulling" out a <em>single</em> return value from its call.</p>
<p>C++ provides pull-based iteration through input streams (eg. <b>std::fstream</b>). In this model, the consumer explicitly requests data from a passive producer, repeatedly "pulling" <em>multiple</em> values as needed. This approach is commonly used when reading lines from a file, where each pull retrieves the next piece of data.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">PRODUCER   </th><th class="markdownTableHeadNone">CONSUMER    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Pull</b>   </td><td class="markdownTableBodyNone"><b>Passive:</b> produces data when requested.   </td><td class="markdownTableBodyNone"><b>Active:</b> decides when data is requested.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Push</b>   </td><td class="markdownTableBodyNone"><b>Active:</b> produces data at its own pace.   </td><td class="markdownTableBodyNone"><b>Passive:</b> reacts to received data.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md10"></a>
What is Push?</h2>
<p>In Push systems, the Producer determines when to send data to the Consumer. The Consumer does not control when it will receive that data.</p>
<p>In C++, <code>std::future</code> represents a common Push system. A <code>std::promise</code> (the Producer) sets a value asynchronously, and the associated <code>std::future</code> (the Consumer) retrieves it once it becomes available. Unlike regular function calls, where the caller dictates execution, the Producer determines exactly when the value is "pushed" to the callbacks.</p>
<p>RxLite introduces Observables, a new Push system for C++. An Observable is a Producer of multiple values, "pushing" them to Observers (Consumers).</p>
<ul>
<li>A <b>Function</b> is a lazily evaluated computation that synchronously returns a single value on invocation.</li>
<li>An <b>Input Stream</b> is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on read.</li>
<li>A <b>Future</b> is a computation that may (or may not) eventually return a single value.</li>
<li>An <b>Observable</b> is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Observables as Generalizations of Functions</h1>
<p>Contrary to common misconceptions, Observables are not just <code>std::future</code> extended to multiple values.</p>
<blockquote class="doxtable">
<p>&zwj;Observables are like functions with zero arguments, but generalize those to allow multiple values. </p>
</blockquote>
<p>Consider the following:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> foo = []() {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 42;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> x = foo();</div>
<div class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordtype">int</span> y = foo();</div>
<div class="line">std::cout &lt;&lt; y &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>We expect to see as output:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
<div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
</div><!-- fragment --><p>You can write the same behavior above, but with Observables:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> foo([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    subscriber.next(42);</div>
<div class="line">});</div>
<div class="line">    </div>
<div class="line">foo.<a class="code hl_function" href="classRxLite_1_1Observable.html#a608425b026ac4c1f3b5f01bd1df678f1">subscribe</a>([](<span class="keywordtype">int</span> x) {</div>
<div class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line">foo.subscribe([](<span class="keywordtype">int</span> y) {</div>
<div class="line">    std::cout &lt;&lt; y &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="ttc" id="aclassRxLite_1_1Observable_html_a608425b026ac4c1f3b5f01bd1df678f1"><div class="ttname"><a href="classRxLite_1_1Observable.html#a608425b026ac4c1f3b5f01bd1df678f1">RxLite::Observable::subscribe</a></div><div class="ttdeci">Subscription subscribe(Observer&lt; T &gt; observer) const</div><div class="ttdoc">Subscribes an observer to the observable.</div><div class="ttdef"><b>Definition</b> observable.hpp:89</div></div>
</div><!-- fragment --><p>And the output is the same:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
<div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
</div><!-- fragment --><p>This happens because both functions and Observables are lazy computations. If you don't call the function, the <code>std::cout &lt;&lt; "Hello" &lt;&lt; std::endl</code> won't happen. Also with Observables, if you don't "call" it (with <code>subscribe</code>), the <code>std::cout &lt;&lt; "Hello" &lt;&lt; std::endl</code> won't happen. Plus, "calling" or "subscribing" is an isolated operation: two function calls trigger two separate side effects, and two Observable subscribes trigger two separate side effects.</p>
<blockquote class="doxtable">
<p>&zwj;Subscribing to an Observable is analogous to calling a Function. </p>
</blockquote>
<p>Some people claim that Observables are asynchronous. That is not true. If you surround a function call with logs, like this:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;before&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; foo() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;after&quot;</span> &lt;&lt; std::endl</div>
</div><!-- fragment --><p>You will see the output:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;before&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
<div class="line"><span class="stringliteral">&quot;after&quot;</span></div>
</div><!-- fragment --><p>And this is the same behavior with Observables:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;before&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">foo.subscribe([](<span class="keywordtype">int</span> x) {</div>
<div class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;after&quot;</span> &lt;&lt; std::endl</div>
</div><!-- fragment --><p>And the output is:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;before&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
<div class="line"><span class="stringliteral">&quot;after&quot;</span></div>
</div><!-- fragment --><p>Which proves the subscription of <code>foo</code> was entirely synchronous, just like a function.</p>
<blockquote class="doxtable">
<p>&zwj;Observables are able to deliver values either synchronously or asynchronously. </p>
</blockquote>
<p>What is the difference between an Observable and a function? <b>Observables can "return" multiple values over time</b>, something which functions cannot. You can't do this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> foo() {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 42;</div>
<div class="line">    <span class="keywordflow">return</span> 100; <span class="comment">// dead code. will never happen</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Functions can only return one value. Observables, however, can do this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> foo([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    subscriber.next(42);</div>
<div class="line">    subscriber.next(100); <span class="comment">// &quot;return&quot; another value</span></div>
<div class="line">    subscriber.next(200); <span class="comment">// &quot;return&quot; yet another</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;before&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">foo.<a class="code hl_function" href="classRxLite_1_1Observable.html#a608425b026ac4c1f3b5f01bd1df678f1">subscribe</a>([](<span class="keywordtype">int</span> x) {</div>
<div class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;after&quot;</span> &lt;&lt; std::endl</div>
</div><!-- fragment --><p>With synchronous output:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;before&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
<div class="line">100</div>
<div class="line">200</div>
<div class="line"><span class="stringliteral">&quot;after&quot;</span></div>
</div><!-- fragment --><p>But you can also "return" values asynchronously:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> foo([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hello&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    subscriber.next(42);</div>
<div class="line">    subscriber.next(100);</div>
<div class="line">    subscriber.next(200);</div>
<div class="line">    std::thread([subscriber = subscriber.shared_from_this()]() {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">        subscriber.next(300);</div>
<div class="line">    }).detach();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;before&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// Important: We must hold the returned Subscription to ensure it remains active.</span></div>
<div class="line"><a class="code hl_class" href="classRxLite_1_1Subscription.html">RxLite::Subscription</a> subscription = foo.subscribe([](<span class="keywordtype">int</span> x) {</div>
<div class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;after&quot;</span> &lt;&lt; std::endl</div>
</div><!-- fragment --><p>With output:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;before&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">42</div>
<div class="line">100</div>
<div class="line">200</div>
<div class="line"><span class="stringliteral">&quot;after&quot;</span></div>
<div class="line">300</div>
</div><!-- fragment --><p><b>Note</b>: Since our subscriber function is asynchronous, it will be marked as finished before the function completes, if we dont hold the <code>Subscription</code>.</p>
<p>Conclusion:</p>
<ul>
<li><code>func.call()</code> means "give me one value synchronously"</li>
<li><code>observable.subscribe()</code> means "give me any amount of values, either synchronously or asynchronously"</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Anatomy of an Observable</h1>
<p>Observables are <b>created</b> using the <code>Observable constructor</code> or one of its <code>static member functions</code> (eg. <code>Observable&lt;T&gt;::of</code> or <code>Observable&lt;T&gt;::from</code>), are <b>subscribed</b> to with an Observer, execute to deliver <code>next</code> / <code>error</code> / <code>complete</code> notifications to the Observer, and their execution may be <b>disposed</b>. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, like Observer and Subscription.</p>
<p>Core Observable concerns:</p><ul>
<li><b>Creating</b> Observables</li>
<li><b>Subscribing</b> to Observables</li>
<li><b>Executing</b> the Observable</li>
<li><b>Disposing</b> Observables</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Creating Observables</h2>
<p>The <code>Observable</code> constructor takes one argument: the <code>onSubscribe</code> function.</p>
<p>The following example creates an Observable to emit the string <code>"hi"</code> every second to a subscriber.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;std::string&gt;</a> observable([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;std::string&gt;</a>&amp; subscriber) {</div>
<div class="line">    std::thread([subscriber = subscriber.shared_from_this()]() {</div>
<div class="line">        while (true) {</div>
<div class="line">            subscriber.next(<span class="stringliteral">&quot;hi&quot;</span>);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">        }</div>
<div class="line">    }).detach();</div>
<div class="line">});</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;Observables can be created with its <code>constructor</code>. Most commonly, observables are created using creation functions, like <code>of</code>, <code>from</code>, <code>interval</code>, etc. </p>
</blockquote>
<p>In the example above, the subscribe function is the most important piece to describe the Observable. Let's look at what <code>subscribing</code> means.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Subscribing to Observables</h2>
<p>The Observable <code>observable</code> in the example can be subscribed to, like this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Subscription.html">RxLite::Subscription</a> subscription = observable.subscribe([](std::string s)  {</div>
<div class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl</div>
<div class="line">});</div>
</div><!-- fragment --><p>Calls to <code>subscribe</code> are not shared among multiple Observers of the same Observable. When calling <code>observable.subscribe</code> with an Observer, the <code>onSubscribe</code> function is run for that given subscriber. Each call to <code>observable.subscribe</code> triggers its own independent setup for that given subscriber.</p>
<blockquote class="doxtable">
<p>&zwj;Subscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to. </p>
</blockquote>
<p>With <code>observable.subscribe</code>, the given Observer is not registered as a listener in the Observable. The Observable does not even maintain a list of attached Observers. A <code>subscribe</code> call is simply a way to start an "Observable execution" and deliver values or events to an Observer of that execution.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Executing Observables</h2>
<p>The code inside the <code>onSubscribe</code> represents an "Observable execution", a lazy computation that only happens for each Observer that subscribes. The execution produces multiple values over time, either synchronously or asynchronously.</p>
<p>There are three types of values an Observable Execution can deliver:</p>
<ul>
<li>"Next" notification: sends a value such as a Number, a String, an Object, etc.</li>
<li>"Error" notification: sends a JavaScript Error or exception.</li>
<li>"Complete" notification: does not send a value.</li>
</ul>
<p>"Next" notifications are the most important and most common type: they represent actual data being delivered to a subscriber. "Error" and "Complete" notifications may happen only once during the Observable Execution, and there can only be either one of them.</p>
<div class="fragment"><div class="line">next*(error|complete)?</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards. </p>
</blockquote>
<p>The following is an example of an Observable execution that delivers three Next notifications, then completes:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> observable([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">    subscriber.next(1);</div>
<div class="line">    subscriber.next(2);</div>
<div class="line">    subscriber.next(3);</div>
<div class="line">    subscriber.complete();</div>
<div class="line">});</div>
</div><!-- fragment --><p>Observables strictly adhere to the Observable Contract, so the following code would not deliver the Next notification <code>4</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> observable([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">    subscriber.next(1);</div>
<div class="line">    subscriber.next(2);</div>
<div class="line">    subscriber.next(3);</div>
<div class="line">    subscriber.complete();</div>
<div class="line">    subscriber.next(4); <span class="comment">// Is not delivered because it would violate the contract</span></div>
<div class="line">});</div>
</div><!-- fragment --><p>It can be a good idea to wrap any code in subscribe with try/catch block that will deliver an Error notification if it catches an exception:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> observable([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;int&gt;</a>&amp; subscriber) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        subscriber.next(1);</div>
<div class="line">        subscriber.next(2);</div>
<div class="line">        subscriber.next(3);</div>
<div class="line">        subscriber.complete();</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        subscriber.error(std::current_exception()); <span class="comment">// delivers an error if it caught one</span></div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Disposing Observable Executions</h2>
<p>Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.</p>
<p>When <code>observable.subscribe</code> is called, the Observer becomes a <code>Subcriber</code> and gets attached to the newly created Observable execution. This call also returns an object, the Subscription:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Subscription.html">RxLite::Subscription</a> subscription = observable.subscribe([](<span class="keywordtype">int</span> i)  {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl</div>
<div class="line">});</div>
</div><!-- fragment --><p>The Subscription represents the ongoing execution, and has a minimal API which allows you to cancel that execution. With <code>subscription.unsubscribe()</code> you can cancel the ongoing execution:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;int&gt;</a> observable = <a class="code hl_function" href="classRxLite_1_1Observable.html#a8e8ba5920ed7790cd13a86e332776214">RxLite::Observable&lt;int&gt;::from</a>({10, 20, 30});</div>
<div class="line"><a class="code hl_class" href="classRxLite_1_1Subscription.html">RxLite::Subscription</a> subscription = observable.<a class="code hl_function" href="classRxLite_1_1Observable.html#a608425b026ac4c1f3b5f01bd1df678f1">subscribe</a>([](<span class="keywordtype">int</span> i)  {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl</div>
<div class="line">});</div>
<div class="line"><span class="comment">// Later:</span></div>
<div class="line">subscription.unsubscribe();</div>
<div class="ttc" id="aclassRxLite_1_1Observable_html_a8e8ba5920ed7790cd13a86e332776214"><div class="ttname"><a href="classRxLite_1_1Observable.html#a8e8ba5920ed7790cd13a86e332776214">RxLite::Observable::from</a></div><div class="ttdeci">static Observable&lt; T &gt; from(std::vector&lt; T &gt; values)</div><div class="ttdoc">Creates an observable that emits a sequence of values from a vector.</div><div class="ttdef"><b>Definition</b> observable.hpp:68</div></div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;When you subscribe, you get back a Subscription, which represents the ongoing execution. Just call unsubscribe() to cancel the execution </p>
</blockquote>
<p>If a Subscription gets copied both hold a reference to the ongoing execution. A Subcription can also be added to another Subscription with <code>subscription.add</code>. To prevent resource leaks, the execution will be canceled after the last Subcription which holds its reference gets destroyed.</p>
<p>Each Subscriber must define how to dispose resources of that execution. You can do that by returning a custom cleanup function from within function <code>subscribe()</code>.</p>
<p>For instance, this is how we clear an interval execution set with <code>std::thread.detach</code>:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Observable&lt;std::string&gt;</a> observable([](<span class="keyword">const</span> <a class="code hl_class" href="classRxLite_1_1Observable.html">RxLite::Subscriber&lt;std::string&gt;</a>&amp; subscriber) -&gt; RxLite::TeardownLogic {</div>
<div class="line">        std::shared_ptr&lt;std::atomic&lt;bool&gt;&gt; stopFlag = std::make_shared&lt;std::atomic&lt;bool&gt;&gt;(<span class="keyword">false</span>);</div>
<div class="line">        </div>
<div class="line">        std::thread([subscriber, stopFlag]() {</div>
<div class="line">            <span class="keywordflow">while</span> (!stopFlag-&gt;load()) {</div>
<div class="line">                subscriber.next(<span class="stringliteral">&quot;hi&quot;</span>);</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">            }</div>
<div class="line">        }).detach();</div>
<div class="line">    </div>
<div class="line">        <span class="keywordflow">return</span> [stopFlag]() {</div>
<div class="line">            stopFlag-&gt;store(<span class="keyword">true</span>);</div>
<div class="line">        };</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classRxLite_1_1Subscription.html">RxLite::Subscription</a> subscription = observable.<a class="code hl_function" href="classRxLite_1_1Observable.html#a608425b026ac4c1f3b5f01bd1df678f1">subscribe</a>([](<span class="keyword">const</span> std::string&amp; s) {</div>
<div class="line">        std::cout &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(6));</div>
<div class="line">    subscription.unsubscribe(); <span class="comment">// dispose the resources</span></div>
</div><!-- fragment --><p>With output:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;hi&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;hi&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;hi&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;hi&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;hi&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;hi&quot;</span></div>
</div><!-- fragment --><p>The reason why we use Rx types like Observable, Observer, and Subscription is to get safety (such as the Observable Contract) and composability with Operators.</p>
<p><br  />
<br  />
<br  />
 </p><blockquote class="doxtable">
<p>&zwj;<small> This documentation is based on the <a href="https://rxjs.dev/">RxJS documentation</a>, licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>. Changes may have been made. </small> </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
